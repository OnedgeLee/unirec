experiment: exp_scaffold
mode: serve
resources:
  item_embeddings: resources/item_emb.npy      # np.ndarray shape (N, d)
  item_ids: null                                    # optional list of ids aligned to embeddings
  categories: {}                                    # optional {item_id: category}
pipeline:
  - id: retrieve1
    kind: candidate_retriever
    impl: unirec.plugins.candidate_retriever.twotower_retriever_simple:TwotowerRetrieverSimple
    params: { topk: 500 }
  - id: retrieve2
    kind: candidate_retriever
    impl: unirec.plugins.candidate_retriever.twotower_retriever_simple:TwotowerRetrieverSimple
    params: { topk: 500 }
  - id: merge
    kind: candidiate_merger
    impl: unirec.plugins.candidate_merger.union:WeightedUnion
    params:
      weights: { retrieve1: 0.6, retrieve2: 0.4 }
      topk: 800
  - id: shape
    kind: candidate_shaper
    impl: unirec.plugins.candidate_shaper.mmr:MMR
    params: { lambda: 0.2 }
  - id: slate_policy
    kind: slate_policy
    impl: unirec.plugins.slate_policy.bandit_ucb:UCBSequentialSlate
    params:
      K: 10
      alpha: 0.25
      position_weights: [1.0, 0.85, 0.75, 0.68, 0.62, 0.57, 0.53, 0.50, 0.47, 0.45]
      diversity_lambda: 0.15
  - id: evaluate
    kind: evaluator
    impl: unirec.plugins.eval.evaluator:OfflineEvaluator
    params:
      K: 10
      metrics: ["NDCG@10", "Recall@10", "ILD@10", "Entropy@10", "Coverage@10"]
